Link: https://archive.org/details/ucberkeley_webcast_TTK2lZoWbPQ

---

Recursion does NOT 'Go Back' -- don't think that!!

CS is not really a science - -we're not usually finding things out but rather building things. we're engineers and artists Or Software Enginnering. Computer Science is the control of complexity.

Programming is easy, as long as your program is small.

we manage complexity by building our programs out of bigger chunks. We manage those chunks with 'programming paradigms'

Abstraction -- the central idea of this course. In the sense that we'll be using it for the course, it's best understood as cummulative layer: each next-higer lever is built on the previous ones, becoming 'more' abstract as we move 'up' (i.e. a more abstract layer is built on top of a less abstract layer.)

FUNCTIONAL PROGRAMMING

functional programming is especially important for parallelization

a function has zero or more inputs and one output. everytime you put in the same input(s) you will receive the same output. a function doesn't care what's inside itself -- we can call two functions the same if for every input they produce identical outputs. I *think* this makes sense from a mathematical perspective: If for every input the same output is produced, then one should be able to use algebra, etc, to convert the procedures of one to the other.

Procedures are sequences of steps for a function. i.e. It DOES care about the differece between it and a similiar-output-producing function.

a function with free variables (i.e. a variable that's not part of the input) is not a function in our sense.

functions are constructs for OUR benefits -- computers only have procedures.